# Grasp Generation

This folder is for generating grasps under a table top setting. For the rest of this file, we asume that the table plane is the `z=0` plane of the world reference frame. So we need to first generate some transformation matrices to transform each object onto the top of the table before we start generating grasps. 



## Dependencies

### Common Packages

```bash
conda create -n dexgraspnet python=3.9
conda activate dexgraspnet

conda install pytorch3d

conda install transforms3d
conda install trimesh
conda install plotly

pip install sapien  # simulator for generating table top scenes

pip install urdf_parser_py

conda install tensorboardx  # this seems to be useless
conda install tensorboard
conda install setuptools=59.5.0

conda install python-kaleido  # soft dependency for plotly

pip install yapf
conda install nbformat  # soft dependency for plotly
pip install networkx  # soft dependency for trimesh
conda install rtree  # soft dependency for trimesh
pip install --user healpy
```

### TorchSDF

[TorchSDF](https://github.com/wrc042/TorchSDF) is a our custom version of [Kaolin](https://github.com/NVIDIAGameWorks/kaolin). 

```bash
git clone git@github.com:wrc042/TorchSDF.git
cd torchsdf
git checkout 0.1.0
bash install.sh
```

### Pytorch Kinematics

We modified [pytorch_kinematics](https://github.com/UM-ARM-Lab/pytorch_kinematics) to increase calculation speed. The code is included in this repo. 

```bash
cd thirdparty/pytorch_kinematics
pip3 install -e .
```



## Usage

First, create a folder `data` in the base directory of this repo, and add soft links as follows: 

* `meshdata`: Linked to the output folder of asset processing. 
* `poses`: Linked to a folder in the data disk. Record multiple pose matrices that can transform each object onto the top of a table (the `z=0` plane). 
* `experiments`: Linked to a folder in the data disk. Small-scale experimental results go here. 
* `graspdata`: Linked to a folder in the data disk. Large-scale generated grasps go here, waiting for grasp validation. 
* `dataset`: Linked to a folder in the data disk. Validated results go here. 

Next, run `python grasp_generation/scripts/generate_object_pose.py`. Each object in `data/meshdata` is raised to a random height above the table, rotated randomly, then dropped onto the table in a free fall. This process is repeated `--n_samples` times to collect diverse poses, which will be recorded in `data/poses`. 

Now, run `python grasp_generation/main.py` to generate grasps. For each instance, a random entry from `data/poses/object_code.npy` is selected to transform the object onto the top of the table. Extra constraints are added to the initialization process to ensure that every hand is initialized above the table. During optimization, an extra energy term `E_tpen` is added to ensure that the hand stays above the table. This is defined as the sum of the penetration distances of all links. This script logs energy curves and outputs to `data/experiments/<name>`. Use `tensorboard --logdir=data/experiments/<name>` to visualize the energy curves. 



## Visualization Scripts

`python visualize_object_pose.py`: visualizes an object in the world reference frame. In this frame, the `z=0` plane represents the table. The object lies on top of this table. This pose is generated by letting the object fall randomly from a high place (in simulator SAPIEN). This script shows how to set the object scale. 

`python visualize_result.py`: visualizes a single grasp in the world reference frame (so the `z=0` plane is the table). This script shows how to set the rotation around the `z` axis. 



## Data Format

Each `data/poses/source(-category)-code.npy` contains a list of transformation matrices. Each matrix is a `4x4` homogeneous transformation matrix, that can transform the object mesh from the object reference frame (where the object is normalized inside a zero-centered unit sphere) to the world reference frame (where the table surface coincides with the `z=0` plane). Note that the transformation matrices need to be rescaled along with the objects. Refer to `grasp_generation/tests/visualize_object_pose.py` for more details. 

Each `data/graspdata/source(-category)-code.npy` contains a list of data dicts. Each dict represents one synthesized grasp: 

* `scale`: The scale of the object. 
* `plane`: Plane parameters (A, B, C, D) in the object reference frame, $Ax + By + Cz + D >= 0$ means the region above the table, $A^2 + B^2 + C^2 = 1$, so $Ax + By + Cz + D$ means the height above the table. 
* `qpos`: The final grasp pose $g=(T,R,\theta)$, which is logged as a dict: 
  * `WRJTx,WRJTy,WRJTz`: Translations in meters. 
  * `WRJRx,WRJRy,WRJRz`: Rotations in euler angles, following the xyz convention. 
  * `robot0:XXJn`: Articulations passed to the forward kinematics system. 
* `qpos_st`: The initial grasp pose logged like `qpos`. This entry will be removed after grasp validation. 
* `energy,E_fc,E_dis,E_pen,E_spen,E_joints`: Final energy terms. These entries will be removed after grasp validation. 

Refer to `grasp_generation/tests/visualize_result.py` for more information. 



## Notes

The table penetration energy term `E_tpen` is an L1 penalty for penetration distance. However, users might want to modify the code to start punishing grasps when the distance is smaller than `delta` to guarantee safety for real robot experiments. The following modification to `grasp_generation/utils/energy.py` does the trick: 

```python
    # loss table pen
    plane_distances = hand_model.cal_dis_plane(object_model.plane_parameters)  # [B, n_links]
    plane_distances -= delta  # add this line, choose delta arbitrarily
    plane_distances[plane_distances > 0] = 0
    E_tpen = -plane_distances.sum(-1)
```



